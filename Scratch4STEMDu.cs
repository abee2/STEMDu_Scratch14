'From MIT Squeak 0.9.4 (June 1, 2003) [No updates present.] on 11 February 2012 at 7:35:02 pm'!"Change Set:		NanoBoardAGWithMotorsDate:			27 December 2011Author:			Kazuhiro ABE <abee@squeakland.jp>This changeset enables to use a NanoBoardAG as a WeDo and a ScratchBoard.It requires a NanoBoardAG with a sketch named NanoBoardAGWithMotors.pde and two DC motors."!Morph subclass: #ScratchFrameMorph	instanceVariableNames: 'topPane viewerPane scriptsPane stageFrame workPane titlePane libraryPane menuPanel stageButtonsPanel readoutPane logoMorph projectTitleMorph flagButton fillScreenFlag paintingInProgress projectDirectory projectName projectInfo author loginName loginPassword watcherPositions shuffledCostumeNames justSaved viewModeButtons viewMode lastViewMode viewModeButtonsPanel toolbarPanel lastWeDoPoll wedoIsOpen '	classVariableNames: 'Clipboard DefaultNotes DefaultSprite Fonts FontsXO IsXO ScratchServers ScratchSkin ScratchSkinXO TakeOverScreen UseErrorCatcher Version VersionDate VisibleDrives WorkpaneExtent '	poolDictionaries: ''	category: 'Scratch-UI-Panes'!Morph subclass: #SensorBoardMorph	instanceVariableNames: 'column titleMorph portName port readouts sensorValues currentState highByte useGoGoProtocol scratchBoardV3 reportRaw scanPorts scanState scanStartMSecs lastPollMSecs command '	classVariableNames: ''	poolDictionaries: ''	category: 'Scratch-UI-Panes'!!ScratchFrameMorph methodsFor: 'accessing' stamp: 'ka 12/26/2011 23:32'!frame	^ self! !!ScratchFrameMorph methodsFor: 'stepping' stamp: 'ka 12/26/2011 23:17'!checkForWeDo	"Check for WeDo, and show motor blocks if it is found."	"Note: Polling on Vista can take several hundred milliseconds, so reduce polling to just a few times per minute."	| now |	now _ Time millisecondClockValue.	(lastWeDoPoll isNil or: [lastWeDoPoll > now]) ifTrue: [lastWeDoPoll _ 0].	((now - lastWeDoPoll) < 15000) ifTrue: [^ wedoIsOpen == true]. "don't poll too often"	lastWeDoPoll _ now.	WeDoPlugin readInputs.	(wedoIsOpen _ WeDoPlugin isOpen) ifTrue: [		workPane showMotorBlocks ifTrue: [^ wedoIsOpen].		self showMotorBlocks.		WeDoPlugin readInputs].	workPane sensorBoard portIsOpen		ifTrue: 			[workPane showMotorBlocks ifTrue: [^ wedoIsOpen].			self showMotorBlocks].	^ wedoIsOpen! !!ScriptableScratchMorph methodsFor: 'motor ops' stamp: 'ka 12/25/2011 15:24'!allMotorsReset	| sensorBoard |	sensorBoard _ (self ownerThatIsA: ScratchStageMorph) sensorBoard.	sensorBoard command: nil! !!ScriptableScratchMorph methodsFor: 'motor ops' stamp: 'ka 12/27/2011 17:46'!motor: motorName direction: directionName	"Set the direction of the given motor."	| dir stage |	stage _ self ownerThatIsA: ScratchStageMorph.	stage owner frame checkForWeDo ifTrue: [		dir _ 0.		(directionName includesSubString: 'reverse') ifTrue: [dir _ 0].		(directionName includesSubString: 'this way') ifTrue: [dir _ 1].		(directionName includesSubString: 'that way') ifTrue: [dir _ -1].		'A' = motorName ifTrue: [WeDoPlugin motorADirection: dir].		'B' = motorName ifTrue: [WeDoPlugin motorBDirection: dir].		' ' = motorName ifTrue: [			WeDoPlugin motorADirection: dir.			WeDoPlugin motorBDirection: dir]].	stage sensorBoard motor: motorName direction: directionName! !!ScriptableScratchMorph methodsFor: 'motor ops' stamp: 'ka 12/27/2011 17:36'!motorOff: motorName	"Turn the given motor off."	| stage |	stage _ self ownerThatIsA: ScratchStageMorph.	stage owner frame checkForWeDo ifTrue: [		'A' = motorName ifTrue: [WeDoPlugin motorAOn: false].		'B' = motorName ifTrue: [WeDoPlugin motorBOn: false].		' ' = motorName ifTrue: [			WeDoPlugin motorAOn: false.			WeDoPlugin motorBOn: false]].	stage sensorBoard motorOff: motorName! !!ScriptableScratchMorph methodsFor: 'motor ops' stamp: 'ka 12/27/2011 17:44'!motorOn: motorName	"Turn the given motor on."	| stage |	stage _ self ownerThatIsA: ScratchStageMorph.	stage owner frame checkForWeDo ifTrue: [		'A' = motorName ifTrue: [WeDoPlugin motorAOn: true].		'B' = motorName ifTrue: [WeDoPlugin motorBOn: true].		' ' = motorName ifTrue: [			WeDoPlugin motorAOn: true.			WeDoPlugin motorBOn: true]].	stage sensorBoard motorOn: motorName ! !!ScriptableScratchMorph methodsFor: 'motor ops' stamp: 'ka 8/10/2010 21:22'!motorOn: motorID For: secs elapsed: elapsedMSecs dummy: dummy	"Turn all motors on for the given number of seconds."	motorID ifNil: [  "first call, start motor"		self motorOn: ' '.		^ #' '].	self motorOn: motorID.	elapsedMSecs >= (1000 * secs) ifTrue: [self motorOff: motorID].! !!ScriptableScratchMorph methodsFor: 'motor ops' stamp: 'ka 12/27/2011 17:45'!startMotor: motorName power: power 	| stage |	stage _ self ownerThatIsA: ScratchStageMorph.	stage owner frame checkForWeDo ifTrue: [		self motor: motorName power: power.		self motorOn: motorName.].		stage sensorBoard motorOn: motorName power: power! !!ScriptableScratchMorph methodsFor: 'motor ops' stamp: 'ka 12/25/2011 15:34'!startMotorPower: power 	self startMotor: ' ' power: power ! !!ScratchStageMorph methodsFor: 'scratch processes/events' stamp: 'ka 11/21/2011 16:48'!stopAll	"Stop all processes and make sure I am stepping."	| sFrame |	World hands do: [:h | h newKeyboardFocus: nil; clearUnclaimedKeystrokes].	Sensor clearKeystate.	SoundPlayer stopPlayingAll.	self class stopSoundRecorder.	self stopAllProcesses.	self stopAsks.	self deleteAllClones.	self midiAllNotesOff.	self allMotorsReset.	WeDoPlugin resetWeDo.	self stopPlaying.	self allMorphsDo: [:m |		(m isKindOf: ScriptableScratchMorph) ifTrue: [m stopPlaying]].	(sFrame _ self ownerThatIsA: ScratchFrameMorph) ifNotNil: [		sFrame scriptsPane allMorphsDo: [:m |			(m respondsTo: #stop) ifTrue: [m stop].			(m respondsTo: #litUp:) ifTrue: [m litUp: false]].		World startSteppingSubmorphsOf: sFrame].	World startSteppingSubmorphsOf: self.! !!ScriptableScratchMorph class methodsFor: 'block specs' stamp: 'ka 12/27/2011 18:19'!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)		M	motor number"	| blocks |	blocks _ #(		'control'			('when %m clicked'				S	-)			('when %k key pressed'			K	-)			('when %m clicked'				M	-)			-			('wait %n secs'					t	wait:elapsed:from: 1)			-			('forever'						c	doForever)			('repeat %n'						c	doRepeat 10)			-			('broadcast %e'					-	broadcast:)			('broadcast %e and wait'			s	doBroadcastAndWait)			('when I receive %e'			E	-)			-			('forever if %b'					c	doForeverIf)			('if %b'							c	doIf)			('if %b'							c	doIfElse)			('wait until %b'					s	doWaitUntil)			('repeat until %b'				c	doUntil)			-			('stop script'					s	doReturn)			('stop all'						-	stopAll)		'operators'			('%n + %n'						r	+ - -)			('%n - %n'						r	- - -)			('%n * %n'						r	* - -)			('%n / %n'						r	/ - -)			-			('pick random %n to %n'		r	randomFrom:to: 1 10)			-			('%s < %s'						b	< '' '')			('%s = %s'						b	= '' '')			('%s > %s'						b	> '' '')			-			('%b and %b'					b	&)			('%b or %b'						b	|)			('not %b'						b	not)			-			('join %s %s'					r	concatenate:with: 'hello ' 'world')			('letter %n of %s'				r	letter:of: 1 'world')			('length of %s'					r	stringLength: 'world')			-			('%n mod %n'					r	\\ - -)			('round %n'						r	rounded -)			-			('%f of %n'						r	computeFunction:of: 'sqrt' 10)		'sound'			('play sound %S'				-	playSound:)			('play sound %S until done'		s	doPlaySoundAndWait)			('stop all sounds'				-	stopAllSounds)			-			('play drum %D for %n beats'	t 	drum:duration:elapsed:from: 48 0.2)			('rest for %n beats'				t 	rest:elapsed:from: 0.2)			-			('play note %N for %n beats'	t	noteOn:duration:elapsed:from: 60 0.5)			('set instrument to %I'			- 	midiInstrument: 1)			-			('change volume by %n'		- 	changeVolumeBy: -10)			('set volume to %n%'			- 	setVolumeTo: 100)			('volume'						r 	volume)			-			('change tempo by %n'			- 	changeTempoBy: 20)			('set tempo to %n bpm'			- 	setTempoTo: 60)			('tempo'							r 	tempo)		'motor'			('motor %M on for %n secs'			t	motorOn:For:elapsed:dummy: ' ' 1)			('motor %M on'						-	motorOn: ' ')			('motor %M off'						-	motorOff: ' ')			('motor %M power %n'				-	startMotor:power: ' ' 100)			('motor %M direction %W'			-	motor:direction: ' ' 'this way')		'variables'			('show variable %v'				-	showVariable:)			('hide variable %v'				-	hideVariable:)		'list'			('add %s to %L'					-	append:toList: 'thing')			-			('delete %y of %L'				-	deleteLine:ofList: 1)			('insert %s at %i of %L'			-	insert:at:ofList: 'thing' 1)			('replace item %i of %L with %s'		-	setLine:ofList:to: 1 'list' 'thing')			-			('item %i of %L'					r	getLine:ofList: 1)			('length of %L'					r	lineCountOfList:)			('%L contains %s'				b	list:contains: 'list' 'thing')	).	^ blocks, self obsoleteBlockSpecs! !!SensorBoardMorph methodsFor: 'accessing' stamp: 'ka 2/11/2012 19:33'!command	command isNil ifTrue: [command _ 2r10001000].	^ command! !!SensorBoardMorph methodsFor: 'accessing' stamp: 'ka 12/31/2009 23:43'!command: number	command _ number! !!SensorBoardMorph methodsFor: 'private' stamp: 'ka 1/1/2010 11:54'!processIncomingData	"Process incoming bytes from the serial port."	"Details: To work around a problem with the Prolific USB-Serial drivers on some Windows machines, a strict turn-taking polling protocol is used. A poll byte is sent, the ScratchBoard sends a response, and after a small delay (to be sure that all the data from the last poll has arrived, another poll is sent. The goal is to never allow more that few bytes to accumulate in the serial input buffer and to avoid sending a poll byte while data is arriving. However, since different versions of the ScratchBoard may send different amounts of data, we don't want to hard-code the number of reply bytes. Thus"	| buf msecsSinceLastPoll byte |	(self portIsOpen and: [#on = scanState]) ifFalse: [^ self].	useGoGoProtocol ifTrue: [		buf _ port readByteArray.		buf do: [:b | self processGoGoByte: b].		^ self].	msecsSinceLastPoll _ Time millisecondClockValue - lastPollMSecs.	msecsSinceLastPoll < 20 ifTrue: [^ self].	buf _ port readByteArray.	buf do: [:b | self processScratchByte: b].	byte _ (self command min: 255) max: 0.	port nextPut: byte.	"send a ScratchBoard V4 poll byte"	lastPollMSecs _ Time millisecondClockValue.! !!SensorBoardMorph methodsFor: 'fake wedo ops' stamp: 'ka 12/27/2011 17:46'!motor: motorName direction: directionName	"Set the direction of the given motor."	| cmd |	cmd _ self command.	('A' = motorName or: [' ' = motorName]) ifTrue: [		(directionName includesSubString: 'reverse')			ifTrue: [cmd _ cmd bitXor: 2r10000000].		(directionName includesSubString: 'this way')			ifTrue: [cmd _ cmd bitOr: 2r10000000].		(directionName includesSubString: 'that way')			ifTrue: [cmd _ cmd bitAnd: 2r01111111]].	('B' = motorName or: [' ' = motorName]) ifTrue: [		(directionName includesSubString: 'reverse')			ifTrue: [cmd _ cmd bitXor: 2r00001000].		(directionName includesSubString: 'this way')			ifTrue: [cmd _ cmd bitOr: 2r00001000].		(directionName includesSubString: 'that way')			ifTrue: [cmd _ cmd bitAnd: 2r11110111]].	self command: cmd! !!SensorBoardMorph methodsFor: 'fake wedo ops' stamp: 'ka 12/27/2011 17:31'!motorOff: motorName	"Turn the given motor off."	| cmd |	cmd _ self command.	('A' = motorName or: [' ' = motorName]) ifTrue: [cmd _ cmd bitAnd: 2r10001111].	('B' = motorName or: [' ' = motorName]) ifTrue: [cmd _ cmd bitAnd: 2r11111000].	self command: cmd! !!SensorBoardMorph methodsFor: 'fake wedo ops' stamp: 'ka 1/11/2012 16:21'!motorOn: motorName 	'A' = motorName ifTrue: [self motorOn: motorName power: WeDoPlugin motorAPower].	'B' = motorName ifTrue: [self motorOn: motorName power: WeDoPlugin motorBPower].	' ' = motorName		ifTrue: 			[self motorOn: 'A'.			self motorOn: 'B']! !!SensorBoardMorph methodsFor: 'fake wedo ops' stamp: 'ka 1/11/2012 16:04'!motorOn: motorName power: power 	| cmd |	cmd _ self command.	('A' = motorName or: [' ' = motorName])		ifTrue: 			[cmd _ cmd bitAnd: 143.			cmd _ cmd bitOr: ((7 / 100 * (power abs min: 100) max: 0) rounded bitShift: 4).			WeDoPlugin setMotorAPower: power].	('B' = motorName or: [' ' = motorName])		ifTrue: 			[cmd _ cmd bitAnd: 248.			cmd _ cmd bitOr: (7 / 100 * (power abs min: 100) max: 0) rounded.			WeDoPlugin setMotorBPower: power].	self command: cmd! !!WeDoPlugin class methodsFor: 'motor control' stamp: 'ka 12/27/2011 00:07'!motorAPower: aNumber	"Set the power level to the absolute value of the given number. The range is 0-100."	self setMotorAPower: aNumber.	self updateMotors.! !!WeDoPlugin class methodsFor: 'motor control' stamp: 'ka 12/27/2011 00:07'!motorBPower: aNumber	"Set the power level to the absolute value of the given number. The range is 0-100."	self setMotorBPower: aNumber.	self updateMotors.! !!WeDoPlugin class methodsFor: 'private' stamp: 'ka 12/27/2011 00:08'!motorAPower	^ MotorAPower! !!WeDoPlugin class methodsFor: 'private' stamp: 'ka 12/27/2011 00:08'!motorBPower	^ MotorBPower! !!WeDoPlugin class methodsFor: 'private' stamp: 'ka 12/27/2011 00:06'!setMotorAPower: aNumber	"Set the power level to the absolute value of the given number. The range is 0-100."	MotorAPower _ aNumber abs! !!WeDoPlugin class methodsFor: 'private' stamp: 'ka 12/27/2011 00:06'!setMotorBPower: aNumber	"Set the power level to the absolute value of the given number. The range is 0-100."	MotorBPower _ aNumber abs! !